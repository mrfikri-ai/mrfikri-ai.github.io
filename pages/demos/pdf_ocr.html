<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF OCR Converter – Make PDF Searchable (Client-Side)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Tesseract.js (WASM) with cache-busting -->
  <script src="https://unpkg.com/tesseract.js@5.0.2/dist/tesseract.min.js?v=2"></script>
  <!-- pdf.js for rendering PDF pages to canvases before OCR -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/pdf.min.js?v=2" integrity="sha512-eJqggrdM1vJrqVYgOL9gir1PAlb08otA6DphMstewdAkSK+QGdIKF3Gtg9Ojd0NbXwV3kDLEZHnpKNTM3t85ow==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <!-- Performance hints: Preload worker, wasm & traineddata for faster, steadier init -->
  <link rel="preload" as="script" href="https://unpkg.com/tesseract.js@5.0.2/dist/worker.min.js" crossorigin="anonymous" />
  <link rel="preload" as="fetch" href="https://tessdata.projectnaptha.com/5.0.0_fast/eng.traineddata.gz" crossorigin="anonymous" />
  <link rel="preload" as="script" href="https://unpkg.com/tesseract.js-core@5.0.0/tesseract-core.wasm.js" crossorigin="anonymous" />
  <script>
    // Configure pdf.js worker
    if (window['pdfjsLib']) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/pdf.worker.min.js';
    }
  </script>
  <style>
    body { font-family: 'Inter', sans-serif; }
    .drop-active { border-color:#0284c7; background:#f0f9ff; }
    .progress-striped {
      background-image: linear-gradient(45deg,rgba(255,255,255,.25) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.25) 50%,rgba(255,255,255,.25) 75%,transparent 75%,transparent);
      background-size: 1rem 1rem;
      animation: move 1s linear infinite;
    }
    @keyframes move { from { background-position:0 0; } to { background-position:1rem 0; } }
  </style>
</head>
<body class="bg-stone-100 min-h-screen flex flex-col">
  <!-- Navbar (reuse site style) -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark sticky-top">
    <div class="container mx-auto px-4">
      <a class="navbar-brand text-white font-semibold" href="/">Muhamad Rausyan Fikri</a>
      <div class="ms-auto flex gap-4 text-sm">
        <a class="text-white/80 hover:text-white" href="/">Home</a>
        <a class="text-white/80 hover:text-white" href="../research.html">Research</a>
        <a class="text-white/80 hover:text-white" href="../publication.html">Publications</a>
        <a class="text-white/80 hover:text-white" href="../pro_grant.html">Projects & Grants</a>
        <a class="text-white/80 hover:text-white" href="../blog.html">Blog</a>
      </div>
    </div>
  </nav>

  <main class="flex-1 container mx-auto max-w-4xl px-4 py-8">
    <h1 class="text-3xl font-bold text-stone-800 mb-2">PDF OCR Converter</h1>
    <p class="text-stone-600 mb-6">Convert a non-searchable (scanned) PDF into a searchable (text-layer) PDF entirely in your browser. <span class="font-semibold">No files are uploaded to any server</span>; processing is temporary and stays on your device. After you download the output, the in-memory data is cleared.</p>

    <section class="bg-white/90 backdrop-blur rounded-xl shadow border border-stone-200 p-6">
      <div class="grid md:grid-cols-2 gap-6">
        <!-- Upload / Actions -->
        <div>
          <h2 class="text-lg font-semibold text-stone-700 mb-3">1. Upload PDF</h2>
          <div id="dropzone" class="relative border-2 border-dashed border-stone-300 rounded-lg p-6 text-center transition-colors cursor-pointer">
            <input id="file-input" type="file" accept="application/pdf" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer" />
            <p class="text-stone-600"><span class="font-medium">Click</span> or <span class="font-medium">drag & drop</span> a PDF here.</p>
            <p id="file-info" class="mt-2 text-xs text-stone-400"></p>
          </div>

          <!-- Password Prompt (shown only if PDF is encrypted) -->
          <div id="password-wrapper" class="mt-4 hidden">
            <label for="pdf-password" class="block text-sm font-medium text-stone-700 mb-1">PDF Password Required</label>
            <input id="pdf-password" type="password" placeholder="Enter password" class="w-full rounded-md border border-stone-300 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-sky-500 focus:border-sky-500" />
            <p class="text-xs text-amber-600 mt-2" id="password-hint">This PDF is encrypted. Enter the password and click Convert again.</p>
          </div>

          <div class="mt-6 space-y-3">
            <button id="btn-convert" disabled class="w-full py-2.5 rounded-md font-semibold bg-sky-600 disabled:opacity-40 disabled:cursor-not-allowed text-white shadow hover:bg-sky-500 transition">2. Convert to Searchable PDF</button>
            <button id="btn-download" disabled class="w-full py-2.5 rounded-md font-semibold bg-emerald-600 disabled:opacity-40 disabled:cursor-not-allowed text-white shadow hover:bg-emerald-500 transition">3. Download Result</button>
            <button id="btn-reset" class="w-full py-2.5 rounded-md font-medium bg-stone-200 text-stone-700 hover:bg-stone-300 transition">Reset</button>
            <div class="pt-2 border-t border-stone-200 text-xs text-stone-500 leading-snug">
              <div class="flex flex-col gap-2">
                <div class="flex items-center gap-2">
                  <label class="font-medium text-stone-600">Optimization Level</label>
                  <select id="opt-level" class="border border-stone-300 rounded px-2 py-1 bg-white text-stone-700">
                    <option value="0">O0 - No optimization (highest quality)</option>
                    <option value="1" selected>O1 - Mild (grayscale + modest downsample)</option>
                    <option value="2">O2 - Aggressive (grayscale + threshold)</option>
                    <option value="3">O3 - Max speed (binarize + strong downsample)</option>
                  </select>
                </div>
                <p class="text-[10px] leading-snug text-stone-500">Higher level => faster & smaller, potential quality loss. Inspired by OCRmyPDF optimization tiers.</p>
              </div>
            </div>
          </div>
        </div>

        <!-- Progress & Log -->
        <div>
          <h2 class="text-lg font-semibold text-stone-700 mb-3">Progress</h2>
          <div class="mb-4">
            <div class="h-4 w-full bg-stone-200 rounded overflow-hidden">
              <div id="progress-bar" class="h-full w-0 bg-sky-600 progress-striped"></div>
            </div>
            <p id="progress-text" class="mt-2 text-sm text-stone-600">Idle</p>
          </div>
          <div class="bg-stone-50 border border-stone-200 rounded-lg p-3 h-56 overflow-auto text-xs font-mono" id="log"></div>
          <p class="mt-4 text-xs text-stone-500">Limitations: Large multi-page PDFs may take a while (OCR runs page-by-page). Keep this tab active to ensure smooth progress.</p>
        </div>
      </div>
    </section>

    <section class="mt-10 text-sm text-stone-600 leading-relaxed">
      <h2 class="text-lg font-semibold text-stone-700 mb-2">How it works</h2>
      <ul class="list-disc ms-6 space-y-1">
        <li>Your PDF is processed locally using WebAssembly (Tesseract.js). No server upload.</li>
        <li>An OCR text layer is embedded so you can select, copy, and search text in the resulting PDF.</li>
        <li>After downloading, all in-memory references & object URLs are cleared. Refresh or click Reset to purge state sooner.</li>
      </ul>
    </section>
  </main>

  <footer class="py-6 text-center text-xs text-stone-500">Client-side OCR Demo • Tesseract.js • No data leaves your browser.</footer>

<script>
(function(){
  // Elements
  const fileInput = document.getElementById('file-input');
  const dropzone = document.getElementById('dropzone');
  const fileInfo = document.getElementById('file-info');
  const btnConvert = document.getElementById('btn-convert');
  const btnDownload = document.getElementById('btn-download');
  const btnReset = document.getElementById('btn-reset');
  const progressBar = document.getElementById('progress-bar');
  const progressText = document.getElementById('progress-text');
  const logEl = document.getElementById('log');

  // State
  let selectedFile = null;
  let worker = null;
  let pdfArrayBuffer = null; // OCR output buffer
  let objectUrl = null;
  let lastProgressPhase = '';
  let pdfPassword = null;
  let encryptedDetected = false;
  let optimizationLevel = 1; // 0..3
  let initTimeMs = null; let initStart = null;
  const ASSET_CACHE_NAME = 'ocr-assets-v1';
  const OCR_ASSETS = [
    'https://unpkg.com/tesseract.js@5.0.2/dist/worker.min.js',
    'https://unpkg.com/tesseract.js-core@5.0.0/tesseract-core.wasm.js',
    'https://tessdata.projectnaptha.com/5.0.0_fast/eng.traineddata.gz'
  ];

  // Prefetch & cache assets early to smooth init variability
  async function prefetchAssets(){
    if(!('caches' in window)) return; // older browsers
    try {
      const cache = await caches.open(ASSET_CACHE_NAME);
      await Promise.all(OCR_ASSETS.map(async url => {
        const match = await cache.match(url);
        if(!match){
          const res = await fetch(url, { mode:'cors', integrity: undefined, cache:'reload' }).catch(()=>null);
          if(res && res.ok) await cache.put(url, res.clone());
        }
      }));
      log('Assets prefetched to cache.');
    } catch(e){ /* silent */ }
  }

  function log(msg){
    const time = new Date().toLocaleTimeString('en-US',{hour12:false});
    logEl.textContent += `[${time}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function setProgress(pct, label){
    progressBar.style.width = pct + '%';
    progressText.textContent = label + (pct ? ` (${pct.toFixed(1)}%)` : '');
  }
  function resetState(){
    selectedFile = null; pdfArrayBuffer = null; setProgress(0,'Idle');
    fileInfo.textContent = ''; btnConvert.disabled = true; btnDownload.disabled = true;
    if(objectUrl){ URL.revokeObjectURL(objectUrl); objectUrl=null; }
    if(worker){ /* keep worker cached for speed */ }
    logEl.textContent='';
  }

  // Drag & Drop UI
  ['dragenter','dragover'].forEach(evt=>dropzone.addEventListener(evt,e=>{e.preventDefault();e.stopPropagation();dropzone.classList.add('drop-active');}));
  ['dragleave','drop'].forEach(evt=>dropzone.addEventListener(evt,e=>{e.preventDefault();e.stopPropagation();dropzone.classList.remove('drop-active');}));
  dropzone.addEventListener('drop', e=>{ const f = e.dataTransfer.files[0]; if(f) handleFile(f); });
  fileInput.addEventListener('change', e=>{ const f = e.target.files[0]; if(f) handleFile(f); });

  function handleFile(f){
    if(f.type !== 'application/pdf'){ log('Rejected: not a PDF.'); return; }
    selectedFile = f; fileInfo.textContent = `${f.name} (${(f.size/1024/1024).toFixed(2)} MB)`; log(`Loaded file: ${f.name}`);
    btnConvert.disabled = false; btnDownload.disabled = true; pdfArrayBuffer=null; if(objectUrl){ URL.revokeObjectURL(objectUrl); objectUrl=null; }
  // Reset password UI if a new file is chosen
  encryptedDetected = false; pdfPassword=null;
  document.getElementById('password-wrapper').classList.add('hidden');
  document.getElementById('pdf-password').value='';
  }

  async function initWorker(){
    if(worker) return worker;
    initStart = performance.now();
    log('Init OCR engine (warming)...');
    setProgress(2,'Init');
    try {
      worker = await Tesseract.createWorker({
        // Explicit paths mitigate some CSP / CDN resolution issues.
        workerPath: 'https://unpkg.com/tesseract.js@5.0.2/dist/worker.min.js',
        corePath:   'https://unpkg.com/tesseract.js-core@5.0.0/tesseract-core.wasm.js',
        langPath:   'https://tessdata.projectnaptha.com/5.0.0_fast',
        logger: m => {
          if(m.status && lastProgressPhase !== m.status){ lastProgressPhase = m.status; log('STATUS: '+m.status); }
        }
      });
      // Attempt fast language first; fallback mirror if fails
      try {
        await worker.loadLanguage('eng');
      } catch(langErr){
        log('Primary lang mirror failed, retrying fallback...');
        // Fallback to standard tessdata repo
        await worker.loadLanguage('https://tessdata.projectnaptha.com/5.0.0/eng');
      }
      await worker.initialize('eng');
      await worker.setParameters({ tessedit_create_pdf: '1' });
      initTimeMs = performance.now() - initStart;
      log('OCR engine ready in '+ initTimeMs.toFixed(0)+'ms (cached: '+ (initTimeMs<1500?'yes':'no') +').');
      return worker;
    } catch(e){
      console.error('Worker init error', e);
      log('Init error: ' + (e?.message || JSON.stringify(e) || 'Unknown')); 
      log('Troubleshooting: 1) Hard refresh (Ctrl+F5) to bypass cache. 2) Check network console for blocked CDN requests. 3) Corporate/firewall may block unpkg or tessdata CDN.');
      throw e;
    }
  }

  async function streamPdfAndOcr(file, password, ocrWorker){
    if(!window.pdfjsLib){ throw new Error('pdf.js not loaded'); }
    const arrayBuf = await file.arrayBuffer();
    let pdf;
    try {
      pdf = await pdfjsLib.getDocument({ data: arrayBuf, password }).promise;
    } catch(e){
      if(e && e.name === 'PasswordException'){
        // Indicate password required or incorrect
        throw { type: 'PASSWORD', code: e.code, message: e.message };
      }
      throw e;
    }
    log(`Pages: ${pdf.numPages}`);
      for(let pageNum=1; pageNum<=pdf.numPages; pageNum++){
      const page = await pdf.getPage(pageNum);
        const viewport = page.getViewport({ scale: calcScale(page, optimizationLevel) });
      // Use OffscreenCanvas if available for slightly better perf
      let canvas, ctx;
      if(typeof OffscreenCanvas !== 'undefined'){
        canvas = new OffscreenCanvas(viewport.width, viewport.height);
        ctx = canvas.getContext('2d');
      } else {
        canvas = document.createElement('canvas');
        canvas.width = viewport.width; canvas.height = viewport.height;
        ctx = canvas.getContext('2d');
      }
      const startRender = performance.now();
      await page.render({ canvasContext: ctx, viewport }).promise;
      const renderMs = (performance.now()-startRender).toFixed(0);
      setProgress(((pageNum-1)/pdf.numPages)*85 + 5, `OCR Page ${pageNum}/${pdf.numPages}`);
  applyPreprocess(canvas, ctx, optimizationLevel);
  const bmp = (canvas instanceof OffscreenCanvas) ? canvas.transferToImageBitmap() : canvas; // pass directly
      const startOcr = performance.now();
      const { data } = await ocrWorker.recognize(bmp);
      log(`P${pageNum}: ${(performance.now()-startOcr).toFixed(1)}s OCR, ${renderMs}ms render, chars ${data.text.length}`);
    }
  }

  btnConvert.addEventListener('click', async ()=>{
    if(!selectedFile) return;
    btnConvert.disabled = true; btnDownload.disabled = true; pdfArrayBuffer=null; setProgress(0,'Preparing');
  log(`Starting OCR (Level O${optimizationLevel}). Keep tab active.`);
    const startAll = performance.now();
    try {
      const w = await initWorker();
      await streamPdfAndOcr(selectedFile, pdfPassword, w);
      setProgress(92,'Build PDF');
      const pdf = await w.getPDF('ocr_result');
      pdfArrayBuffer = pdf.data;
      setProgress(100,'Done');
      log('OCR complete. Ready to download.');
      btnDownload.disabled = false;
      const totalSecs = ((performance.now()-startAll)/1000).toFixed(1);
      log(`Total time: ${totalSecs}s`);
    } catch(err){
      if(err && err.type === 'PASSWORD'){
        encryptedDetected = true;
        log((err.code === 1 ? 'Password required.' : 'Wrong password.') + ' Please enter password and click Convert again.');
        document.getElementById('password-wrapper').classList.remove('hidden');
        btnConvert.disabled = false;
        setProgress(0, err.code === 1 ? 'Password Needed' : 'Wrong Password');
        return;
      }
      console.error(err); log('Error: '+ (err.message||err)); setProgress(0,'Failed'); btnConvert.disabled = false;
    }
  });

  // Capture password input changes
  const passwordInput = document.getElementById('pdf-password');
  passwordInput.addEventListener('input', e => { pdfPassword = e.target.value || null; });

  // Optimization level change
  document.getElementById('opt-level').addEventListener('change', e => { optimizationLevel = parseInt(e.target.value,10); log('Optimization Level set to O'+optimizationLevel); });

  // Preload worker during idle time after minimal user interaction to shorten perceived wait.
  let preloadScheduled = false;
  function schedulePreload(){
    if(preloadScheduled || worker) return; preloadScheduled = true;
  const kickoff = ()=>{ prefetchAssets().then(()=>initWorker()).then(()=>log('OCR engine preloaded.')).catch(()=>{}); };
    if('requestIdleCallback' in window){ requestIdleCallback(kickoff,{timeout:3500}); } else { setTimeout(kickoff, 2500); }
  }
  ['mousemove','scroll','keydown','touchstart'].forEach(evt => window.addEventListener(evt, schedulePreload, { once:true, passive:true }));
  // Also attempt after load in case no interaction
  window.addEventListener('load', ()=> setTimeout(schedulePreload, 1500));

  // ---- Optimization helpers ----
  function calcScale(page, level){
    // Base unscaled viewport
    const baseViewport = page.getViewport({ scale:1 });
    const w = baseViewport.width; const h = baseViewport.height;
    // Target max pixels per page (rough heuristics)
    const maxPixels = [ w*h, 3_000_000, 2_000_000, 1_000_000 ][level];
    if(level===0) return 2.4; // high quality fixed upscale
    // Start from scale 2.0 for better accuracy; adjust down to meet maxPixels
    let scale = 2.0;
    let pixels = w*h*scale*scale;
    if(pixels > maxPixels){
      scale = Math.sqrt(maxPixels/(w*h));
    }
    // Slightly reduce scale for highest aggression
    if(level===3) scale *= 0.95;
    return Math.max(0.6, scale);
  }

  function applyPreprocess(canvas, ctx, level){
    if(level===0) return; // no optimization
    const w = canvas.width, h = canvas.height;
    const imgData = ctx.getImageData(0,0,w,h);
    const data = imgData.data;
    // grayscale + optional threshold
    let sum=0, len = data.length/4;
    for(let i=0;i<data.length;i+=4){
      const r=data[i], g=data[i+1], b=data[i+2];
      let y = (r*0.299 + g*0.587 + b*0.114);
      sum += y;
      data[i]=data[i+1]=data[i+2]=y;
    }
    if(level>=2){
      const avg = sum/len;
      // dynamic threshold: bias lower for level 3
      const thresh = (level===3 ? avg*0.9 : avg*0.95);
      for(let i=0;i<data.length;i+=4){
        const v = data[i] < thresh ? 0 : 255;
        data[i]=data[i+1]=data[i+2]=v;
      }
    }
    ctx.putImageData(imgData,0,0);
  }

  btnDownload.addEventListener('click', ()=>{
    if(!pdfArrayBuffer) return;
    if(objectUrl){ URL.revokeObjectURL(objectUrl); objectUrl=null; }
    const blob = new Blob([pdfArrayBuffer], { type: 'application/pdf' });
    objectUrl = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = objectUrl;
    a.download = (selectedFile?.name?.replace(/\.pdf$/i,'') || 'ocr_result') + '_searchable.pdf';
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
    log('Download triggered. Clearing in-memory data...');
    setTimeout(()=>{ pdfArrayBuffer=null; if(objectUrl){ URL.revokeObjectURL(objectUrl); objectUrl=null; } btnDownload.disabled=true; log('In-memory PDF cleared.'); }, 1500);
  });

  btnReset.addEventListener('click', resetState);
  window.addEventListener('beforeunload', resetState);
})();
</script>
</body>
</html>
